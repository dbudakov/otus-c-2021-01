# Dynamic data structures

## Выделение памяти, stdlib.h

**malloc**(количество * размер) – выделение памяти (memory allocation), выделяется одна большая строка  
**calloc**(количество, размер) – выделение памяти **с заполнением НУЛЯМИ**  
уронит программу, если памяти недостаточно  
**realloc**(указатель, новый размер памяти) – изменение размера ранее выделенной памяти.  

### Очистка памяти

**free**(указатель), освобождение памяти  
yказатель = NULL, желательно обнулить указатель

Изменять указатель не рекоммендуется: (pointer++), потому что не удасться освободить память(free), так как изменятся границы указателя

## Двумерный массив

Варианты работы с двумерными массивами:  

```c

// Классическое обращение к элементу
mas[n][m]


// вычисление индекса элемента
// Здесь: i умножается на длину строки(напр.4) прибавляется 2, получается 6 элемент
// n*m*(тип массива) - размер
index = i * m + j

// Обращение к элементу
// Аналогично первому, но используется разыменованный указатель, к которому прибавляется адрес нулевого элемента
*(mas + i * m +j)
```

### Очистка памяти, двумерного массива

```c
int** mas, n = 2, m =3;

mas = (int** )malloc(n * sizeof(int*));
for (int i = 0; i < n; ++i)
	mas[i] = (int*)malloc(m * sizeof(int));


for (int i = 0; i < n; ++i)
	free(mas[i]);
free(mas);
```

### Cвободный массив

Свободный массив - двумерный массив, в котором размер строк может различаться  
Для выделения памяти под массив, вводится второй массив содержащий размеры строк и под строки выделяется память в зависимости от размера

```c
int** mas;
int *m, n = 4;

// массив для строк
mas = (int**)malloc(n * sizeof(int*));

// массив для размеров строк
m = (int*)malloc(n * sizeof(int));

for (int i = 0; i < n; ++i)
{
	printf("count colums in str %d - ", i);
	scanf("%d", &m[i]);
	
	// выделение памяти под строку
	mas[i] = (int*)malloc(m[i] * sizeof(int));
	for (int j = 0; j < m[i]; ++j)
	{
		printf("mas[%d][%d] =", i, j);
		scanf("%d", &mas[i][j]);
	}
}

for (int i = 0; i < n; ++i)
{
	for (int j = 0; j < m[i]; ++j)
		printf("%5d", mas[i][j]);
	printf("\n");
}

for (int i = 0; i < n; ++i)
	free(mas[i]);
free(mas);
free(m);
```

## Очередь [01:10]

Пинцип FIFO(First In - First Out) - первый пришел, первый вышел, как в очереди супермаркета

## Стек [01:19]

Принцип LIFO(Last In - First Out) - линейная структура данных, в которой добавление и удаление элементов возможно только с одного конца
Опреации со стеком: Добавление(**PUSH**), Удаление с вершины(**POP**)
